{"title":"接口与抽象类的区别","uid":"4e5960fe5840da4510823afbd1096f2f","slug":"接口与抽象类的区别","date":"2022-03-31T01:55:00.000Z","updated":"2022-03-31T02:20:13.417Z","comments":true,"path":"api/articles/接口与抽象类的区别.json","keywords":"GHower 博客 架构 协作 Spring java","cover":null,"content":"<h1 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h1><ol>\n<li>都不能被实例化</li>\n<li>两者的方法必须全部被实现后才能实例化</li>\n</ol>\n<h1 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h1><ol>\n<li>接口只有定义，没有实现(jdk8后可以有一个default方法),<br>抽象类可以有定义和实现，方法可在抽象类中实现。</li>\n<li>抽象类只能一层继承一层，而接口可以做到间接的实现多重继承，<br>当然不是真的多重继承</li>\n<li>接口强调功能实现，而抽象类强调所属关系</li>\n<li>修饰符不同 <ul>\n<li>接口变量默认修饰为<code>public static final</code> ,必须赋初值。</li>\n<li>接口方法默认修饰<code>public abstract</code></li>\n<li>抽象类变量默认修饰为 <code>default</code></li>\n<li>抽象类方法默认为<code>public abstract</code></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"一点说明\"><a href=\"#一点说明\" class=\"headerlink\" title=\"一点说明\"></a>一点说明</h1><p>接口设计是对类的行为进行约束，提供一种机制，强制要求类具有相同的行为。<br>只是约束了行为的有无，不约束具体的行为实现，</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>比如 动物都会叫(公共行为)，但狗和猪的叫声(具体行为实现)不同。</p></blockquote>\n<p>抽象类的设计是代码复用，若类具有相同行为，且方式一致时，可以让这些类<br>派生于同一个抽象类，使得相同的实现代码，只需要写一次，<br>继承的方法虽然可以重写实现，但通常我们不重写它。</p>\n<p>抽象类表达的是一种<code>is A</code>的关系，接口表达的是<code>like A</code>的关系。<br>比如 <code>宝马是车</code> 和 <code>飞机像鸟一样可以飞</code> ， 后者飞机的本质是机械<br>不是真的<code>鸟</code> ，但是也具备鸟的行为特点(<code>飞</code>) 。</p>\n<p>所以，不难得出结论，接口的核心就是定义行为，即实现接口的类可以做什么<br>至于实现类是谁，怎么实现的，接口不关心</p>\n<p>总结： 若关注事务的本质，使用抽象类; 若关注的是操作，用接口；</p>\n","feature":false,"text":"相同点 都不能被实例化 两者的方法必须全部被实现后才能实例化 不同点 接口只有定义，没有实现(jdk8后可以有一个default方法),抽象类可以有定义和实现，方法可在抽象类中实现。 抽象类只能一层继承一层，而接口可以做到间接的实现多重继承，当然不是真的多重继承 接口强调功能实现...","link":"","photos":[],"count_time":{"symbolsCount":634,"symbolsTime":"1 mins."},"categories":[{"name":"面试题","slug":"面试题","count":1,"path":"api/categories/面试题.json"}],"tags":[{"name":"java","slug":"java","count":3,"path":"api/tags/java.json"},{"name":"面试题","slug":"面试题","count":1,"path":"api/tags/面试题.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">相同点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">不同点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E7%82%B9%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">一点说明</span></a></li></ol>","author":{"name":"GHower","slug":"blog-author","avatar":"https://blog-gh-site.oss-cn-shenzhen.aliyuncs.com/Logo.png","link":"/","description":"一位正在转移博客的技术人 <br /> @ <b>公众号：GHower</b>","socials":{"github":"https://github.com/GHower","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_40877427","juejin":"https://juejin.cn/user/4503250791314472","customs":{"wechat":{"icon":"/icons/favicons/wechat.png","link":"/icons/favicons/custom/wechat-qrcode.jpg"},"email":{"icon":"/icons/favicons/email.svg","link":"mailto:1520567597@qq.com?subject=主题&body=内容"}}}},"mapped":true,"prev_post":{"title":"GithubPages搭建教程","uid":"415a4ba685615286d7d2dd46636fc692","slug":"GithubPages搭建教程","date":"2022-03-22T15:28:01.000Z","updated":"2022-03-29T10:19:10.942Z","comments":true,"path":"api/articles/GithubPages搭建教程.json","keywords":"GHower 博客 架构 协作 Spring java","cover":[],"text":"一、介绍这里省略300字介绍….. 二、创建自己的GithubPages1.基本页面要创建GithubPages 需要创建一个 username.Github.io的仓库 2.选择GithubPages的主题 3.测试这里以简历的主题做测试，选Cayman theme，来到ind...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"其他","slug":"其他","count":1,"path":"api/categories/其他.json"}],"tags":[{"name":"建站","slug":"建站","count":1,"path":"api/tags/建站.json"}],"author":{"name":"GHower","slug":"blog-author","avatar":"https://blog-gh-site.oss-cn-shenzhen.aliyuncs.com/Logo.png","link":"/","description":"一位正在转移博客的技术人 <br /> @ <b>公众号：GHower</b>","socials":{"github":"https://github.com/GHower","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_40877427","juejin":"https://juejin.cn/user/4503250791314472","customs":{"wechat":{"icon":"/icons/favicons/wechat.png","link":"/icons/favicons/custom/wechat-qrcode.jpg"},"email":{"icon":"/icons/favicons/email.svg","link":"mailto:1520567597@qq.com?subject=主题&body=内容"}}}},"feature":true},"next_post":{"title":"python在列表，元组，字典变量前加_号","uid":"5c7eb2cd430dd8f1d04c4abbeb86267e","slug":"python 在列表，元组，字典变量前加_号。。","date":"2022-03-22T15:28:01.000Z","updated":"2022-03-29T10:15:29.267Z","comments":true,"path":"api/articles/python 在列表，元组，字典变量前加_号。。.json","keywords":"GHower 博客 架构 协作 Spring java","cover":[],"text":"标题在python基础学习中可能遗漏这一点，现在补上；在一个列表、元组或字典变量前加*，结果如下 可以发现，在列表前加*号，会将列表拆分成一个一个的独立元素，不光是列表、元组、字典，由numpy生成的向量也可以拆分； 那这些又有什么用呢？了解过函数中*args和**kwargs的...","link":"","photos":[],"count_time":{"symbolsCount":632,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"python","slug":"python","count":1,"path":"api/tags/python.json"}],"author":{"name":"GHower","slug":"blog-author","avatar":"https://blog-gh-site.oss-cn-shenzhen.aliyuncs.com/Logo.png","link":"/","description":"一位正在转移博客的技术人 <br /> @ <b>公众号：GHower</b>","socials":{"github":"https://github.com/GHower","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_40877427","juejin":"https://juejin.cn/user/4503250791314472","customs":{"wechat":{"icon":"/icons/favicons/wechat.png","link":"/icons/favicons/custom/wechat-qrcode.jpg"},"email":{"icon":"/icons/favicons/email.svg","link":"mailto:1520567597@qq.com?subject=主题&body=内容"}}}},"feature":true}}