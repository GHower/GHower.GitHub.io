[{"id":"e6c644d98e2b92d02366e9ad5ebc1eb5","title":"java8新特性之Stream流操作","content":"介绍Stream流操作是java8的最重要的新特性之一，功能强大,非常常用。可以说每个java coder必须掌握，这次把理论放在最后面，因为你可能不需要知道的多么详细，只是需要看看某个功能，可能听名字就大概知道它是做什么的。\n举个简单例子，现在给了你同学信息和成绩，你需要统计班级平均分\n// 以前可能的做法\npublic static Double avgScore(List&lt;Student> stus)&#123;\n    int sum=0;\n    for (Student student : stus) &#123;\n        int core = student.core;\n        sum += core;\n    &#125;\n    return  ((double)sum / stus.size());\n&#125;\n// 有了Stream后，\npublic static Double avgScore(List&lt;Student> stus)&#123;\n        OptionalDouble average = stus.stream().mapToDouble(stu -> stu.core).average();\n        return average.getAsDouble();\n    &#125;\n流的一些常用操作filterfilter过滤操作，只返回满足条件的数据\nfilter返回的流中只包含满足断言(predicate)的数据\n//输出学生数组中，成绩大于80的学生\npublic static void  sFilter(List&lt;Student> stus)&#123;\n        stus.stream()\n                .filter(student -> student.getCore()>80)\n                .forEach(System.out::println);\n    &#125;\n\ndistinctdistinct输出的流中彼此不同的元素，通过Object.equals(Object)来检查是否包含相同的元素。\n//从数组中找出不同的对象\npublic static void  sDistinct(List&lt;Student> stus)&#123;\n        stus.stream()\n                .distinct()\n                .forEach(System.out::println);\n    &#125;\n\nmap、peek与forEach对比map可以对流中每一个的元素执行操作返回一种元素(可以相同)，可以用来做元素转换\npeek通常用于debug，会通过Consumer对流操作，但操作结果不返回Stream中。\nforEach与map和peek类似，但由于不会返回元素，forEach的返回值是void，可以看做是流的终点操作\n//map,从Student数组中获取由name组成的数组\npublic static void  sMap(List&lt;Student> stus)&#123;\n        List&lt;String> collect = stus.stream()\n                .map(student -> student.getName())\n                .collect(Collectors.toList());\n        stus.forEach(System.out::println);\n        collect.forEach(System.out::println);\n    &#125;\n//forEach，将Student数组中的成绩属性全部加1\npublic static void  sForEach(List&lt;Student> stus)&#123;\n        stus.stream()\n                .forEach(student -> &#123;\n                    student.setCore(student.getCore()+1);\n                &#125;);\n        stus.forEach(System.out::println);\n    &#125;\n\npeek和map的区别，在后面的理论中会对其原理做解释\n// peek\nIntStream.range(1,5).boxed().peek(i-> &#123;\n            i=i+1;\n        &#125;).forEach(System.out::print);\n// 输出结果 1234\n//map\nIntStream.range(1,10).boxed().map(i-> i+1)\n    .forEach(System.out::print);\n// 输出结果 2345\n\n可见peek中虽然对i进行+1操作，但没有改变源数据\nflatMap扁平化处理流，flatMap和map类似，但flatMap转换返回的是Stream对象，而map返回的是数据源的对象，flatMap会把返回的Stream对象中的元素压缩到一起，最后回到原来的流中\nMap&lt;String, List&lt;Integer>> map = new LinkedHashMap&lt;>();\nmap.put(\"a\", Arrays.asList(1, 2, 3));\nmap.put(\"b\", Arrays.asList(4, 5, 6));\n\nList&lt;Integer> allValues = map.values() // Collection&lt;List&lt;Integer>>\n        .stream()                      // Stream&lt;List&lt;Integer>>\n        .flatMap(List::stream)         // Stream&lt;Integer>\n        .collect(Collectors.toList());\n\nSystem.out.println(allValues);\n\n这个例子中，将map.values扁平化处理成单个的Stream。\nsortedsorted对源数据进行排序，通过实现Comparable接口完成排序。\n如果源没有实现Comparable接口，在终点操作时将会抛出java.lang.ClassCastException异常。\n// 按成绩排序，从大到小 \npublic static void sSorted(List&lt;Student> stus) &#123;\n        List&lt;Student> collect = stus.stream()\n            .sorted(Comparator.comparingInt(Student::getCore).reversed())\n            .collect(Collectors.toList());\n        collect.forEach(System.out::println);\n    &#125;\n\nlimitlimit进行短路操作。指定一定数量的元素的流。\npublic static void sLimit(List&lt;Student> stus) &#123;\n        List&lt;Student> collect = stus.stream()\n                .sorted(Comparator.comparingInt(Student::getCore).reversed())\n                .limit(3)\n                .collect(Collectors.toList());\n        collect.forEach(System.out::println);\n    &#125;\n\nboxed将一个原始流转为盒型的流，就是将原始数据类型int，long，double转为Integer，Long，Double\n// 计算average\nOptionalDouble average = IntStream.range(1, 10).average();\nSystem.out.println(average.getAsDouble());\n// peek内的i是Integer类型\nIntStream.range(1,5).boxed().peek(i-> &#123;\n            i=i+1;\n        &#125;).forEach(System.out::print);\n\nskipskip从当前流结果中丢弃前n个元素，返回新的流，如果元素个数小于或等于n，会返回空的流\npublic static void sSkip(List&lt;Student> stus)&#123;\n       List&lt;Student> collect = stus.stream()\n               .limit(3)\n               .skip(2)\n               .collect(Collectors.toList());\n       collect.forEach(System.out::println);\n   &#125;\n\nreducereduce可以看做是map的细节版本，它有两个参数\n\npre：上一次返回的对象\ncur：当前对象\n\nOptional&lt;Integer> reduce = IntStream.range(1,5).boxed().reduce((pre,cur)->&#123;\n         return pre+cur;\n     &#125;);\n     System.out.println(reduce.get());\n\nreduce 还有重载的方法，大概说一下\n// 将使用流中第一个元素作为初始值\npubic Optional&lt;T> reduce(BinaryOperator&lt;T> accumulator)\n// 使用提供的identity作为初始值\npubic T reduce(T identity, BinaryOperator&lt;T> accumulator)\n//同上，但对结果进行combiner操作，可以转为其他类型\npubic &lt;U> U reduce(U identity, BiFunction&lt;U,? super T,U> accumulator, BinaryOperator&lt;U> combiner)\n\n值得注意的是accumulator应该满足结合性(associative)。\nmatchmatch 匹配，它有三个方法：\n\n allMatch若流中所有元素符合条件断言，则返回true，反之为false，流为空则总是返回true \n anyMatch流中有一个及以上符合条件断言，则返回true \n noneMatch流中所有元素不满足条件断言，则返回true \n\npublic static void sMatch(List&lt;Student> stus)&#123;\n        boolean b = stus.stream().allMatch(stu -> stu.getCore() > 80);\n        System.out.println(b);\n        b = stus.stream().anyMatch(stu -> stu.getCore() > 90);\n        System.out.println(b);\n        b = stus.stream().noneMatch(stu -> stu.getCore() > 80);\n        System.out.println(b);\n    &#125;\n\ncountcount 方法返回流中元素的数量、它的底层实现为\nmapToLong(e->1L).sum();\n// 其中sum是原始流的方法\n\ncollectcollect 非常常用了，它将按参数的方法，收集流中的数据组装然后返回一个对象\n// 收集成List\nList&lt;String> asList = stringStream.collect(\n    ArrayList::new, \n    ArrayList::add,\n    ArrayList::addAll\n); \n// 收集成String\nString concat = stringStream.collect(\n    StringBuilder::new, \n    StringBuilder::append,\n    StringBuilder::append)\n.toString();\n\nfind\n findAny从流中任意返回一个元素，串行流比较难看到效果 \n findFirst返回流中第一个元素 \n\n// 若流为空，则返回空的Optional\nOptional&lt;Student> any = stus.stream().findAny();\nOptional&lt;Student> first = stus.stream().findFirst();\n\nmax、min\nmax：返回流中的最大值\nmin：返回流中最小值\n\nboxed型的流需要给出自己的比较器，而原始流不需要\ntoArray()将流中的元素放入到一个数组中。\ncontact连接两个类型一样的流对象\n来一杯理论理论整理来自Javadoc。\n基础Stream流和具体的集合区别。\n\n 不存储数据：流操作基于数据源对象，但本身不存储数据元素，或者说用完即消(使用者是无感知的)，通过管道将数据源元素传递给操作 \n 函数式编程流操作也不会修改数据源，filter、map都不会对源数据做修改 \n 延迟操作流的很多操作如filter,map等中间操作是延迟执行的，只记录了要怎么操作但还没执行，只有到终点操作才会将操作顺序执行。就像点菜一样，下单过程，不是马上做的，而且确定了订单才根据订单做。 \n 解绑对于无限数量的流，有些操作是可以在有限的时间完成的，比如limit(n) 或 findFirst()，这些操作可以实现”短路”(Short-circuiting)，访问到有限的元素后就可以返回。 \n 纯消费流的元素只能访问一次，类似迭代器Iterator，操作没有回头路，如果你想从头重新访问流的元素，那你得重新生成一个新的流。就是说流操作的每一步都是上一步的结果，而初始数据则是源数据。 \n\n流的操作是以管道的方式串起来的。流管道包含一个数据源，接着包含零到N个中间操作，最后以一个终点操作结束。\nStream接口还提供了原语int，long，double级的专门化的流。如IntStream, LongStream 和 DoubleStream。姑且称他们为primitive原始流，是对基本类型执行操作的，不过我们使用流通常是对对象操作。\n创建流创建的方法很多，主要有\n\n集合自带的stream()方法\n集合的静态Arrays.stream(Object[])方法\n流的静态方法，如Stream.of(Object[])\n从文件中获得流，BufferedReader.lines()\n文件类Files 操作路径的方法，如list、find、walk等。\n随机数流Random.ints()\n底层的StreamSupport，它提供了将拆分器Spliterator转换成流的方法。\n\n中间操作 intermediate operations中间操作会返回流对象本身，形成串联的管道，流式风格（fluent style），并且中间操作是延迟的，不会修改源数据，只有在终点操作时才真正执行。\n常见的中间操作\nfilter、distinct、map、peek、sorted、limit、boxed、skip、flatmap、skip、reduce\n终点操作 terminal operations终点操作是真正执行的，会将流的最终结果返回。\n常见的终点操作\nMatch、count、collect、find、forEach、forEachOrdered、max、min、reduce、average、toArray\n1. 流的串行与并行所有的流操作都可以串行执行或者并行执行。除非显示地创建并行流，否则Java库中创建的都是串行流。\n\nCollection.stream()创建串行流，使用parallel()也可以转为并行流\nCollection.parallelStream()创建并行流，使用sequential()方法可以转为串行流。\n\n2. 无干扰 Non-interference流可以从非线程安全的集合中创建，当流的管道执行的时候，非concurrent数据源不应该被改变。\n也就是说，在终点操作(管道执行)时，不能对数据源再做修改，避免并发问题产生无法预料的结果\n// 这会抛出异常java.util.ConcurrentModificationException\nList&lt;Integer> l = new ArrayList(Arrays.asList(1, 2));\n        Stream&lt;Integer> sl = l.stream();\n        sl.forEach(s -> l.add(3));\n\n// 正常\nList&lt;String> l = new ArrayList(Arrays.asList(\"one\", \"two\"));\nStream&lt;String> sl = l.stream();\nl.add(\"three\"); // 在中间操作修改\nsl.forEach(System.out::println);\n\n// 使用concurrent的方式,也正常,但可能有无法预料的结果\nList&lt;String> l = new CopyOnWriteArrayList&lt;>(Arrays.asList(\"one\", \"two\"));\nStream&lt;String> sl = l.stream();\nsl.forEach(s -> l.add(\"three\"));\n\nCopyOnWriteArrayList的参考\n特别的，如果将add换成set，并不会抛异常，因为对象没有被修改，只是内容发生变化。\n3. 结合性一个操作或者函数op满足结合性意味着它满足下面的条件\n(a op b) op c == a op (b op c)\n\n对于并发流来说，如果操作满足结合性，我们就可以并行计算\na op b op c op d == (a op b) op (c op d)\n\n比如min、max以及字符串连接都是满足结合性的。\n4. 排序某些流的返回的元素是有确定顺序的，我们称之为 _encounter order_。\n一个流是否是encounter order主要依赖数据源和它的中间操作，比如数据源List和Array上创建的流是有序的(ordered)，但是在HashSet创建的流不是有序的.\nsorted方法可以将流转换成encounter order的，unordered可以将流转换成encounter order的。\n注意，这个方法并不是对元素进行排序或者打散，而是返回一个是否_encounter order_的流\n\nmap会用不同的类型替换流中的元素，此时，元素的有序性已经没有意义了。\nfilter 执行丢弃了一些值，流的类型没有改变\n\n对于串行流，流有序与否不会影响其性能，只是会影响确定性(determinism)，无序流在多次执行的时候结果可能是不一样的。\n","slug":"java8新特性之Stream流操作","date":"2022-03-22T15:28:01.000Z","categories_index":"java","tags_index":"java,新特性","author_index":"GHower"},{"id":"23c381318a163a9c297db946a6f4c72e","title":"JS中相等判断，三等号===、双等号==、同值Object.is的区别详解","content":"ES6以后有三种判等方法\n\n抽象（非严格）相等比较 (==)\n严格相等(全等)比较 (===)\n同值相等Object.is (ES6新特性)\n\n使用哪一种比较全看你的业务需要，不过一般都用===和Object.is\nMDN中有很详细的介绍，这里直接拿过来用了\n\n\n\n\n\n\n\n\n\n在做相同的比较时，三种方法的区别\n\n 双等号==将执行类型转换， \n 三等号不进行类型转换(如果类型不同, 只是总会返回 false) \n Object.is基本上与三等号相同，但是对于NaN和-0和+0进行特殊处理Object.is（NaN，NaN）将为 true，在==和===中将是false， \n\n严格相等===全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等。最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。\nvar num = 0;\nvar obj = new String(\"0\");\nvar str = \"0\";\nvar b = false;\n\nconsole.log(num === num); // true\nconsole.log(obj === obj); // true\nconsole.log(str === str); // true\n\nconsole.log(num === obj); // false\nconsole.log(num === str); // false\nconsole.log(obj === str); // false\nconsole.log(null === undefined); // false\nconsole.log(obj === null); // false\nconsole.log(obj === undefined); // false\n\n对不同类型的值，全等操作符有不同的处理\n\n 非数值：全等操作符使用明确的语义进行比较：一个值只与自身全等。 \n数值：全等操作符使用略加修改的语义来处理两个特殊情况 \n浮点数 0 , 是不分正负的,全等操作符认为这两个值是全等的\n浮点数包含了 NaN 值,全等操作符认为 NaN 与其他任何值都不全等，包括它自己。\n\n\n\n非严格相等 ==最好永远都不要使用相等操作符。全等操作符的结果更容易预测，并且因为没有隐式转换，全等比较的操作会更快。\n相等操作符比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8mxfsfEm-1619059763128)(assets/1619058832799.png)]\nconsole.log(num == num); // true\nconsole.log(obj == obj); // true\nconsole.log(str == str); // true\n\nconsole.log(num == obj); // true\nconsole.log(num == str); // true\nconsole.log(obj == str); // true\nconsole.log(null == undefined); // true\n\n// 两个都是false，极少数情况会是true\nconsole.log(obj == null);\nconsole.log(obj == undefined);\n\n同值相等Object.is同值相等(Object.is)解决了最后一个用例\n// 向 Nmuber 构造函数添加一个不可变的属性 NEGATIVE_ZERO\nObject.defineProperty(Number, \"NEGATIVE_ZERO\",\n                      &#123; value: -0, writable: false, configurable: false, enumerable: false &#125;);\n\nfunction attemptMutation(v)\n&#123;\n  Object.defineProperty(Number, \"NEGATIVE_ZERO\", &#123; value: v &#125;);\n&#125;\n\nObject.defineProperty 在试图修改不可变属性时，如果这个属性确实被修改了则会抛出异常，反之什么都不会发生。例如如果 v 是 -0 ，那么没有发生任何变化，所以也不会抛出任何异常。但如果 v 是 +0 ，则会抛出异常。不可变属性和新设定的值使用 同值(same-value) 相等比较。\n什么时候使用Object.is或者三等===总的来说，Object.is和===，也就在对NaN的处理才有比较大的不同，如果你不清楚具体的区别，使用===就行了，避免使用Object.is。\n即使你需要比较两个NaN使其结果为true，也可以使用ES6以前的isNan方法。\n","slug":"JS中相等判断，三等号===、双等号==、同值Object.is的区别详解","date":"2022-03-22T15:28:01.000Z","categories_index":"javascript","tags_index":"javascript","author_index":"GHower"},{"id":"415a4ba685615286d7d2dd46636fc692","title":"GithubPages搭建教程","content":"一、介绍这里省略300字介绍…..\n二、创建自己的GithubPages1.基本页面要创建GithubPages 需要创建一个 username.Github.io的仓库\n\n2.选择GithubPages的主题\n\n3.测试这里以简历的主题做测试，选Cayman theme，来到index.md文件，保存查看随后在浏览器输入，username.Github.io即可\n\n如果希望以此作为在线简历，只需要修改index.md文件即可\n\n三、作为博客使用上面已经说了，和halo、hexo一样，最简单的方式就是更换主题即可。\n1. 配置域名和HTTPSGithubPages中已经免费提供了HTTPS，不再需要我们自己提供证书。在云服务器上购买一个域名，并配置域名指向ps: 当然不用自己的域名而用github.io那个也可以。\n\n回到Settings界面的GithubPages中，填写子域名，这里我创建了blog的记录，而我的二级域名是ghower.ltd所以这里填的是blog.ghower.ltd。点击保存后可以看到类似下图的样子。\n\n重新访问blog.ghower.ltd，可以看到一样打开了前面的界面，和username.github.io的方式一样\n\n2. 内容同步在1中已经设置了域名，接下里就是丰富一下这个博客了这里直接使用idea，将仓库下载下来\n\n修改index.md并提交上传即可。但是现在这样的页面还是太简单。我们需要一个静态模板系统来管理博客文章。Github官方推荐使用JekyII，但是那玩意我不会，下面介绍基于Hexo的\n3. 基于Hexo做Pages的生成本地搭建script# 安装hexo-cli\nnpm install -g hexo-cli\n# 初始化一个hexo项目\nhexo init &#x2F;hexo\n# 发表hexo文章\nhexo new &quot;文章名称&quot;\n# 启动hexo\nhexo server\n\n## 默认运行在4000端口\n\n\n\n\n\n\n\n\n\n\n\nhexo new “postName” #新建文章\nhexo new page “pageName” #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help #查看帮助\n配置Hexo\n/_config.yml是站点信息\nthemess/landscape/_config.yml是站点的主题和个人设置\n\n两个会一起使用，根目录下的config.yml相当于全局的\n# Site\ntitle: 邴越的博客 #标题\nsubtitle: 纸上得来终觉浅 #副标题\ndescription: 邴越 博客 架构 写作 #描述\nauthor: 邴越 #作者\nlanguage: zh-CN #语言\ntimezone:  Asia/Shanghai #时区\n\n# URL \nurl: https://bingyue.github.io/   #网址\nroot: / #网站根目录\npermalink: :year/:month/:day/:title/ #文章的永久链接格式\npermalink_defaults: #永久链接中各部分的默认值 \n\n# Directory\nsource_dir: source #源文件，存放内容\npublic_dir: public #公共文件夹，存放生成的站点文件\ntag_dir: tags #标签文件夹\narchive_dir: archives #归档文件夹\ncategory_dir: categories #分类文件夹\ncode_dir: downloads/code\ni18n_dir: :lang #国际化\nskip_render:\n\n# Writing\nnew_post_name: :title.md #新文章标题\ndefault_layout: post #默认模板(post page photo draft)\ntitlecase: false #标题转换成大写\nexternal_link: true #新标签页里打开连接\nfilename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight: #语法高亮\n  enable: true\n  line_number: true #显示行号\n  auto_detect: true\n  tab_replace:\n\n# Category &amp; Tag\ndefault_category: uncategorized #默认分类\ncategory_map:\ntag_map:\n\n# Date / Time format\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination \nper_page: 10 #每页文章数, 设置成 0 禁用分页\npagination_dir: page #分页目录\n\n发布到GithubPages\n安装hexo-deployer-git\n\nscriptnpm install hexo-deployer-git --save\n\n\n配置_config.yml文件\ndeploy:\n  type: git\n  repo: git@github.com:ghower/ghower.github.io.git\n  branch: master\n发布\nscripthexo clean  &amp;&amp; hexo gegerate &amp;&amp; hexo deploy\n\n","slug":"GithubPages搭建教程","date":"2022-03-22T15:28:01.000Z","categories_index":"其他","tags_index":"建站","author_index":"GHower"},{"id":"4e5960fe5840da4510823afbd1096f2f","title":"接口与抽象类的区别","content":"相同点\n都不能被实例化\n两者的方法必须全部被实现后才能实例化\n\n不同点\n接口只有定义，没有实现(jdk8后可以有一个default方法),抽象类可以有定义和实现，方法可在抽象类中实现。\n抽象类只能一层继承一层，而接口可以做到间接的实现多重继承，当然不是真的多重继承\n接口强调功能实现，而抽象类强调所属关系\n修饰符不同 \n接口变量默认修饰为public static final ,必须赋初值。\n接口方法默认修饰public abstract\n抽象类变量默认修饰为 default\n抽象类方法默认为public abstract\n\n\n\n一点说明接口设计是对类的行为进行约束，提供一种机制，强制要求类具有相同的行为。只是约束了行为的有无，不约束具体的行为实现，\n\n\n\n\n\n\n\n\n\n比如 动物都会叫(公共行为)，但狗和猪的叫声(具体行为实现)不同。\n抽象类的设计是代码复用，若类具有相同行为，且方式一致时，可以让这些类派生于同一个抽象类，使得相同的实现代码，只需要写一次，继承的方法虽然可以重写实现，但通常我们不重写它。\n抽象类表达的是一种is A的关系，接口表达的是like A的关系。比如 宝马是车 和 飞机像鸟一样可以飞 ， 后者飞机的本质是机械不是真的鸟 ，但是也具备鸟的行为特点(飞) 。\n所以，不难得出结论，接口的核心就是定义行为，即实现接口的类可以做什么至于实现类是谁，怎么实现的，接口不关心\n总结： 若关注事务的本质，使用抽象类; 若关注的是操作，用接口；\n","slug":"接口与抽象类的区别","date":"2022-03-31T01:55:00.000Z","categories_index":"面试题","tags_index":"java,面试题","author_index":"GHower"},{"id":"5c7eb2cd430dd8f1d04c4abbeb86267e","title":"python在列表，元组，字典变量前加_号","content":"标题在python基础学习中可能遗漏这一点，现在补上；在一个列表、元组或字典变量前加*，结果如下\n\n可以发现，在列表前加*号，会将列表拆分成一个一个的独立元素，不光是列表、元组、字典，由numpy生成的向量也可以拆分；\n\n那这些又有什么用呢？了解过函数中*args和**kwargs的人应该知道，这两个形参都接收若干个参数，通常我们将其称为参数组；          \n\n*args：接收若干个位置参数，转换成元组tuple形式\n**kwargs：接收若干个关键字参数，转换成字典dict形式\n\nps:需要注意的是位置参数*args，一定要在关键字参数**kwargs前看下面的例子；\n\n不难发现，如果不加*，add函数将整个列表当做一个元素使用,也就是add(([1,2,4,5],))。\n而带有*号的参数，此时相当于add((1, 2, 4, 5));\n*号也可以作用于二维的列表；\n\n显然也是将列表进行拆分，结果是两个一维列表；\n\n结果也与上面所说相同；\n这么一看，这个带*变量的作用，就仿佛是把列表解开一层似的，而python中有一个zip函数，功能与之相反。zip是将一个或多个可迭代对象进行包装压缩，返回将结果是列表；\n通俗的说：zip()压缩可迭代对象，*号解压可迭代对象；\n\n\n\n\n\n\n\n\n\n最后需要注意的是：\n\n可迭代对象才可以使用*号拆分；\n带*号变量严格来说并不是一个变量，而更应该称为参数，它是不能赋值给其他变量的，但可以作为参数传递；\n\n","slug":"python 在列表，元组，字典变量前加_号。。","date":"2022-03-22T15:28:01.000Z","categories_index":"","tags_index":"python","author_index":"GHower"},{"id":"fe90f43a8852ee9177afcbd4d51ee774","title":"【设计模式】23种设计模式(java)学前必备课！","content":"六大原则这篇只有部分代码实例。\n1、单一职责原则(Sington Principle)不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。不要让一个类承担过多的职责，避免职责耦合在一起\n2、里氏替换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。\n里氏代换原则中说，任何基类（父类）可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类（子类）可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。\n里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科\n历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。\n所有引用基类（父类）的地方必须能透明地使用其子类的对象。\n3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体实现。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。\n依赖倒置就是为了解决耦合，让程序依赖抽象。一个简单的例子\n// 反例\npublic class Cat&#123;\n    public void run()&#123;..&#125;;\n&#125;\npublic class Dog&#123;\n    public void run()&#123;..&#125;;\n&#125;\npublic class Sys()&#123;\n    private String name;\n    private Cat cat=new Cat();\n    private Dog dog = new Dog();\n    public Sys(String name)&#123;\n        this.name = name;\n    &#125;\n    public void autoRun()&#123;\n        if(\"cat\".equals(name))&#123;\n            cat.run();\n        &#125;else&#123;dog.run();&#125;\n    &#125;\n&#125;\n\n// 应用依赖倒置原则\npublic interface Animal()&#123;\n    public void run();\n&#125;\npublic class Cat implements Animal&#123;\n    @Override\n    public void run()&#123;..&#125;;\n&#125;\npublic class Dog implements Animal&#123;\n    @Override\n    public void run()&#123;..&#125;;\n&#125;\npublic class Sys()&#123;\n    private Animal animal;\n    public Sys(Animal animal)&#123;\n        this.animal = animal;\n    &#125;\n    public void autoRun()&#123;\n        animal.run();\n    &#125;\n&#125;\n\n可以看出不再于具体实现的Cat和Dog类，而是抽象的Animal接口，加入新的动物时也不用怕。\n这种设计也充分说明了，类与类不应该直接依赖细节，因为这样会导致耦合，限制了可扩展性，而是让类与类直接依赖抽象。\n4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。\npublic interface Human&#123;\n    public void run(); \n    public void birth();// 生孩子\n&#125;\npublic class man&#123;..&#125;\npublic class woman&#123;..&#125;\n\n如上，man类可能不需要实现接口中的birth方法，而只使用一个接口让两个类实现的话，两个类中就存在不需要的方法，导致接口没有隔离。\n单一职责和接口隔离原则\n\n单一职责原则注重的是职责，针对的是程序中的实现和细节；\n接口隔离原则注重的是对接口依赖的隔离，主要针对抽象；\n\n5、开闭原则（Open Close Principle）就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不应该去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。依赖倒置中的例子同样违反开闭原则。\n6、合成复用原则（Composite And Reuse Principle）CARP原则是尽量优先使用合成/聚合的方式，而不是使用继承。\n就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。\n复用的两种方式： 合成和继承\n一法则7、迪米特法则（最少知道原则）（Demeter Principle）一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，和我这个类没关系，你只需要通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类，尽量少地影响其他模块，降低系统的耦合度，使类与类之间保持松散的耦合关系。\n最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现在成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。\n设计模式分类总体来说设计模式分三大类：\n\n 创建型模式单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 \n 结构型模式适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 \n 行为模式模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。 \n\n","slug":"【设计模式】23种设计模式(java)学前必备课！","date":"2022-03-22T15:28:01.000Z","categories_index":"java","tags_index":"java,设计模式","author_index":"GHower"},{"id":"c5db3da75c510f866655afbe3577f838","title":"位运算的奇淫巧技","content":"基础知识：1. 位掩码在计算机学科及数字逻辑中指的是一串二进制数字，通过与目标数字的按位操作，达到屏蔽指定位而实现需求\n位运算yyds位运算永远滴神。。。。\n1. 交换两数通过异或运算，交换两个数\na = a^b \nb = a^b \na = a^b \n2. 去除两次出现的数从一堆数(出现一次或两次)中除去出现了两次的数\na = a^b \na = a^b // a又回到原来的值 \n这个操作还是比较有意思的。在Leetcode中第一次见到，大呼内行。。a=a^b执行了两次，导致这个b 在没有更改的情况下对自身异或，其结果自然就是0了。差不多是这样的a=(a^b)^b，看成a=a^0，就会发现，这个b没有了，而0与任何数异或都等于它自身。\n3. 记录三次出现数说实话还没看懂。。。先记下了\nseen_once = seen_twice = 0 \n// 思路: // -仅当seen_twice未变时，改变seen_once \n// -仅当seen_once未变时，改变seen_twice     \n//1. 第一次出现 \nseen_once = ~seen_once &amp; (seen_twice ^ x)     \nseen_twice = ~seen_twice &amp; (seen_once ^ x)     \n//2. 第二次出现     \nseen_once = ~seen_once &amp; (seen_twice ^ x)     \nseen_twice = ~seen_twice &amp; (seen_once ^ x) \t\n//3. 第三次出现     \nseen_once = ~seen_once &amp; (seen_twice ^ x)     \nseen_twice = ~seen_twice &amp; (seen_once ^ x) \n4. 取出最低位的1// 这就能得到一个数，最低位的1 \nx = x &amp; -x \n// 或者\nx &amp;= -x\n\n","slug":"位运算的奇淫巧技","date":"2022-03-22T15:28:01.000Z","categories_index":"算法与题解","tags_index":"算法","author_index":"GHower"}]