{"meta":{"title":"GHower的博客","subtitle":"纸上得来终觉浅，绝知此事要躬行。","description":"好好学，好好看","author":"GHower","url":"http://ghower.github.io"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2022-03-22T23:18:13.011Z","comments":false,"path":"bangumi/index.html","permalink":"http://ghower.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about me","date":"2018-12-12T14:14:36.000Z","updated":"2022-03-29T09:30:18.667Z","comments":false,"path":"about/index.html","permalink":"http://ghower.github.io/about/index.html","excerpt":"","text":"不知道说点什么 晚点再说","keywords":"关于"},{"title":"分类","date":"2022-03-28T08:52:05.000Z","updated":"2022-03-28T09:18:33.083Z","comments":true,"path":"categories/index.html","permalink":"http://ghower.github.io/categories/index.html","excerpt":"","text":"","keywords":"分类"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2022-03-22T23:18:13.012Z","comments":true,"path":"comment/index.html","permalink":"http://ghower.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2022-03-22T23:18:13.012Z","comments":false,"path":"donate/index.html","permalink":"http://ghower.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2022-03-22T23:18:13.011Z","comments":false,"path":"client/index.html","permalink":"http://ghower.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2022-03-22T23:18:13.012Z","comments":false,"path":"lab/index.html","permalink":"http://ghower.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2022-03-28T09:36:58.930Z","comments":true,"path":"links/index.html","permalink":"http://ghower.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"message-board","date":"2022-03-29T04:11:22.000Z","updated":"2022-03-29T04:11:56.919Z","comments":true,"path":"message-board/index.html","permalink":"http://ghower.github.io/message-board/index.html","excerpt":"","text":"这里是留言板"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2022-03-29T04:22:03.610Z","comments":false,"path":"music/index.html","permalink":"http://ghower.github.io/music/index.html","excerpt":"","text":"音乐库","keywords":"喜欢的音乐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2022-03-29T04:20:39.542Z","comments":false,"path":"page-music/index.html","permalink":"http://ghower.github.io/page-music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2022-03-22T23:18:13.014Z","comments":true,"path":"rss/index.html","permalink":"http://ghower.github.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2022-03-29T04:01:01.784Z","comments":true,"path":"tags/index.html","permalink":"http://ghower.github.io/tags/index.html","excerpt":"","text":"这里是标签"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2022-03-22T23:18:13.015Z","comments":false,"path":"video/index.html","permalink":"http://ghower.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"GithubPages搭建教程","slug":"GithubPages搭建教程","date":"2022-03-22T15:28:01.000Z","updated":"2022-03-29T10:19:10.942Z","comments":true,"path":"/post/GithubPages搭建教程.html","link":"","permalink":"http://ghower.github.io/post/GithubPages%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B.html","excerpt":"一、介绍这里省略300字介绍….. 二、创建自己的GithubPages1.基本页面要创建GithubPages 需要创建一个 username.Github.io的仓库 2.选择GithubPages的主题 3.测试这里以简历的主题做测试，选Cayman theme，来到index.md文件，保存查看随后在浏览器输入，username.Github.io即可 如果希望以此作为在线简历，只需要修改index.md文件即可","text":"一、介绍这里省略300字介绍….. 二、创建自己的GithubPages1.基本页面要创建GithubPages 需要创建一个 username.Github.io的仓库 2.选择GithubPages的主题 3.测试这里以简历的主题做测试，选Cayman theme，来到index.md文件，保存查看随后在浏览器输入，username.Github.io即可 如果希望以此作为在线简历，只需要修改index.md文件即可 三、作为博客使用上面已经说了，和halo、hexo一样，最简单的方式就是更换主题即可。 1. 配置域名和HTTPSGithubPages中已经免费提供了HTTPS，不再需要我们自己提供证书。在云服务器上购买一个域名，并配置域名指向ps: 当然不用自己的域名而用github.io那个也可以。 回到Settings界面的GithubPages中，填写子域名，这里我创建了blog的记录，而我的二级域名是ghower.ltd所以这里填的是blog.ghower.ltd。点击保存后可以看到类似下图的样子。 重新访问blog.ghower.ltd，可以看到一样打开了前面的界面，和username.github.io的方式一样 2. 内容同步在1中已经设置了域名，接下里就是丰富一下这个博客了这里直接使用idea，将仓库下载下来 修改index.md并提交上传即可。但是现在这样的页面还是太简单。我们需要一个静态模板系统来管理博客文章。Github官方推荐使用JekyII，但是那玩意我不会，下面介绍基于Hexo的 3. 基于Hexo做Pages的生成本地搭建script# 安装hexo-cli npm install -g hexo-cli # 初始化一个hexo项目 hexo init &#x2F;hexo # 发表hexo文章 hexo new &quot;文章名称&quot; # 启动hexo hexo server ## 默认运行在4000端口 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 配置Hexo /_config.yml是站点信息 themess/landscape/_config.yml是站点的主题和个人设置 两个会一起使用，根目录下的config.yml相当于全局的 # Site title: 邴越的博客 #标题 subtitle: 纸上得来终觉浅 #副标题 description: 邴越 博客 架构 写作 #描述 author: 邴越 #作者 language: zh-CN #语言 timezone: Asia/Shanghai #时区 # URL url: https://bingyue.github.io/ #网址 root: / #网站根目录 permalink: :year/:month/:day/:title/ #文章的永久链接格式 permalink_defaults: #永久链接中各部分的默认值 # Directory source_dir: source #源文件，存放内容 public_dir: public #公共文件夹，存放生成的站点文件 tag_dir: tags #标签文件夹 archive_dir: archives #归档文件夹 category_dir: categories #分类文件夹 code_dir: downloads/code i18n_dir: :lang #国际化 skip_render: # Writing new_post_name: :title.md #新文章标题 default_layout: post #默认模板(post page photo draft) titlecase: false #标题转换成大写 external_link: true #新标签页里打开连接 filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: #语法高亮 enable: true line_number: true #显示行号 auto_detect: true tab_replace: # Category &amp; Tag default_category: uncategorized #默认分类 category_map: tag_map: # Date / Time format date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination per_page: 10 #每页文章数, 设置成 0 禁用分页 pagination_dir: page #分页目录 发布到GithubPages 安装hexo-deployer-git scriptnpm install hexo-deployer-git --save 配置_config.yml文件 deploy: type: git repo: git@github.com:ghower/ghower.github.io.git branch: master 发布 scripthexo clean &amp;&amp; hexo gegerate &amp;&amp; hexo deploy","categories":[{"name":"其他","slug":"其他","permalink":"http://ghower.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"建站","slug":"建站","permalink":"http://ghower.github.io/tags/%E5%BB%BA%E7%AB%99/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"http://ghower.github.io/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"JS中相等判断，三等号===、双等号==、同值Object.is的区别详解","slug":"JS中相等判断，三等号===、双等号==、同值Object.is的区别详解","date":"2022-03-22T15:28:01.000Z","updated":"2022-03-29T11:20:57.736Z","comments":true,"path":"/post/JS中相等判断，三等号===、双等号==、同值Object.is的区别详解.html","link":"","permalink":"http://ghower.github.io/post/JS%E4%B8%AD%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD%EF%BC%8C%E4%B8%89%E7%AD%89%E5%8F%B7===%E3%80%81%E5%8F%8C%E7%AD%89%E5%8F%B7==%E3%80%81%E5%90%8C%E5%80%BCObject.is%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3.html","excerpt":"","text":"ES6以后有三种判等方法 抽象（非严格）相等比较 (==) 严格相等(全等)比较 (===) 同值相等Object.is (ES6新特性) 使用哪一种比较全看你的业务需要，不过一般都用===和Object.is MDN中有很详细的介绍，这里直接拿过来用了 在做相同的比较时，三种方法的区别 双等号==将执行类型转换， 三等号不进行类型转换(如果类型不同, 只是总会返回 false) Object.is基本上与三等号相同，但是对于NaN和-0和+0进行特殊处理Object.is（NaN，NaN）将为 true，在==和===中将是false， 严格相等===全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等。最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。 var num = 0; var obj = new String(\"0\"); var str = \"0\"; var b = false; console.log(num === num); // true console.log(obj === obj); // true console.log(str === str); // true console.log(num === obj); // false console.log(num === str); // false console.log(obj === str); // false console.log(null === undefined); // false console.log(obj === null); // false console.log(obj === undefined); // false 对不同类型的值，全等操作符有不同的处理 非数值：全等操作符使用明确的语义进行比较：一个值只与自身全等。 数值：全等操作符使用略加修改的语义来处理两个特殊情况 浮点数 0 , 是不分正负的,全等操作符认为这两个值是全等的 浮点数包含了 NaN 值,全等操作符认为 NaN 与其他任何值都不全等，包括它自己。 非严格相等 ==最好永远都不要使用相等操作符。全等操作符的结果更容易预测，并且因为没有隐式转换，全等比较的操作会更快。 相等操作符比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8mxfsfEm-1619059763128)(assets/1619058832799.png)] console.log(num == num); // true console.log(obj == obj); // true console.log(str == str); // true console.log(num == obj); // true console.log(num == str); // true console.log(obj == str); // true console.log(null == undefined); // true // 两个都是false，极少数情况会是true console.log(obj == null); console.log(obj == undefined); 同值相等Object.is同值相等(Object.is)解决了最后一个用例 // 向 Nmuber 构造函数添加一个不可变的属性 NEGATIVE_ZERO Object.defineProperty(Number, \"NEGATIVE_ZERO\", &#123; value: -0, writable: false, configurable: false, enumerable: false &#125;); function attemptMutation(v) &#123; Object.defineProperty(Number, \"NEGATIVE_ZERO\", &#123; value: v &#125;); &#125; Object.defineProperty 在试图修改不可变属性时，如果这个属性确实被修改了则会抛出异常，反之什么都不会发生。例如如果 v 是 -0 ，那么没有发生任何变化，所以也不会抛出任何异常。但如果 v 是 +0 ，则会抛出异常。不可变属性和新设定的值使用 同值(same-value) 相等比较。 什么时候使用Object.is或者三等===总的来说，Object.is和===，也就在对NaN的处理才有比较大的不同，如果你不清楚具体的区别，使用===就行了，避免使用Object.is。 即使你需要比较两个NaN使其结果为true，也可以使用ES6以前的isNan方法。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ghower.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ghower.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://ghower.github.io/categories/javascript/"}]},{"title":"java8新特性之Stream流操作","slug":"java8新特性之Stream流操作","date":"2022-03-22T15:28:01.000Z","updated":"2022-03-29T10:29:34.588Z","comments":true,"path":"/post/java8新特性之Stream流操作.html","link":"","permalink":"http://ghower.github.io/post/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81%E6%93%8D%E4%BD%9C.html","excerpt":"","text":"介绍Stream流操作是java8的最重要的新特性之一，功能强大,非常常用。可以说每个java coder必须掌握，这次把理论放在最后面，因为你可能不需要知道的多么详细，只是需要看看某个功能，可能听名字就大概知道它是做什么的。 举个简单例子，现在给了你同学信息和成绩，你需要统计班级平均分 // 以前可能的做法 public static Double avgScore(List&lt;Student> stus)&#123; int sum=0; for (Student student : stus) &#123; int core = student.core; sum += core; &#125; return ((double)sum / stus.size()); &#125; // 有了Stream后， public static Double avgScore(List&lt;Student> stus)&#123; OptionalDouble average = stus.stream().mapToDouble(stu -> stu.core).average(); return average.getAsDouble(); &#125; 流的一些常用操作filterfilter过滤操作，只返回满足条件的数据 filter返回的流中只包含满足断言(predicate)的数据 //输出学生数组中，成绩大于80的学生 public static void sFilter(List&lt;Student> stus)&#123; stus.stream() .filter(student -> student.getCore()>80) .forEach(System.out::println); &#125; distinctdistinct输出的流中彼此不同的元素，通过Object.equals(Object)来检查是否包含相同的元素。 //从数组中找出不同的对象 public static void sDistinct(List&lt;Student> stus)&#123; stus.stream() .distinct() .forEach(System.out::println); &#125; map、peek与forEach对比map可以对流中每一个的元素执行操作返回一种元素(可以相同)，可以用来做元素转换 peek通常用于debug，会通过Consumer对流操作，但操作结果不返回Stream中。 forEach与map和peek类似，但由于不会返回元素，forEach的返回值是void，可以看做是流的终点操作 //map,从Student数组中获取由name组成的数组 public static void sMap(List&lt;Student> stus)&#123; List&lt;String> collect = stus.stream() .map(student -> student.getName()) .collect(Collectors.toList()); stus.forEach(System.out::println); collect.forEach(System.out::println); &#125; //forEach，将Student数组中的成绩属性全部加1 public static void sForEach(List&lt;Student> stus)&#123; stus.stream() .forEach(student -> &#123; student.setCore(student.getCore()+1); &#125;); stus.forEach(System.out::println); &#125; peek和map的区别，在后面的理论中会对其原理做解释 // peek IntStream.range(1,5).boxed().peek(i-> &#123; i=i+1; &#125;).forEach(System.out::print); // 输出结果 1234 //map IntStream.range(1,10).boxed().map(i-> i+1) .forEach(System.out::print); // 输出结果 2345 可见peek中虽然对i进行+1操作，但没有改变源数据 flatMap扁平化处理流，flatMap和map类似，但flatMap转换返回的是Stream对象，而map返回的是数据源的对象，flatMap会把返回的Stream对象中的元素压缩到一起，最后回到原来的流中 Map&lt;String, List&lt;Integer>> map = new LinkedHashMap&lt;>(); map.put(\"a\", Arrays.asList(1, 2, 3)); map.put(\"b\", Arrays.asList(4, 5, 6)); List&lt;Integer> allValues = map.values() // Collection&lt;List&lt;Integer>> .stream() // Stream&lt;List&lt;Integer>> .flatMap(List::stream) // Stream&lt;Integer> .collect(Collectors.toList()); System.out.println(allValues); 这个例子中，将map.values扁平化处理成单个的Stream。 sortedsorted对源数据进行排序，通过实现Comparable接口完成排序。 如果源没有实现Comparable接口，在终点操作时将会抛出java.lang.ClassCastException异常。 // 按成绩排序，从大到小 public static void sSorted(List&lt;Student> stus) &#123; List&lt;Student> collect = stus.stream() .sorted(Comparator.comparingInt(Student::getCore).reversed()) .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; limitlimit进行短路操作。指定一定数量的元素的流。 public static void sLimit(List&lt;Student> stus) &#123; List&lt;Student> collect = stus.stream() .sorted(Comparator.comparingInt(Student::getCore).reversed()) .limit(3) .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; boxed将一个原始流转为盒型的流，就是将原始数据类型int，long，double转为Integer，Long，Double // 计算average OptionalDouble average = IntStream.range(1, 10).average(); System.out.println(average.getAsDouble()); // peek内的i是Integer类型 IntStream.range(1,5).boxed().peek(i-> &#123; i=i+1; &#125;).forEach(System.out::print); skipskip从当前流结果中丢弃前n个元素，返回新的流，如果元素个数小于或等于n，会返回空的流 public static void sSkip(List&lt;Student> stus)&#123; List&lt;Student> collect = stus.stream() .limit(3) .skip(2) .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; reducereduce可以看做是map的细节版本，它有两个参数 pre：上一次返回的对象 cur：当前对象 Optional&lt;Integer> reduce = IntStream.range(1,5).boxed().reduce((pre,cur)->&#123; return pre+cur; &#125;); System.out.println(reduce.get()); reduce 还有重载的方法，大概说一下 // 将使用流中第一个元素作为初始值 pubic Optional&lt;T> reduce(BinaryOperator&lt;T> accumulator) // 使用提供的identity作为初始值 pubic T reduce(T identity, BinaryOperator&lt;T> accumulator) //同上，但对结果进行combiner操作，可以转为其他类型 pubic &lt;U> U reduce(U identity, BiFunction&lt;U,? super T,U> accumulator, BinaryOperator&lt;U> combiner) 值得注意的是accumulator应该满足结合性(associative)。 matchmatch 匹配，它有三个方法： allMatch若流中所有元素符合条件断言，则返回true，反之为false，流为空则总是返回true anyMatch流中有一个及以上符合条件断言，则返回true noneMatch流中所有元素不满足条件断言，则返回true public static void sMatch(List&lt;Student> stus)&#123; boolean b = stus.stream().allMatch(stu -> stu.getCore() > 80); System.out.println(b); b = stus.stream().anyMatch(stu -> stu.getCore() > 90); System.out.println(b); b = stus.stream().noneMatch(stu -> stu.getCore() > 80); System.out.println(b); &#125; countcount 方法返回流中元素的数量、它的底层实现为 mapToLong(e->1L).sum(); // 其中sum是原始流的方法 collectcollect 非常常用了，它将按参数的方法，收集流中的数据组装然后返回一个对象 // 收集成List List&lt;String> asList = stringStream.collect( ArrayList::new, ArrayList::add, ArrayList::addAll ); // 收集成String String concat = stringStream.collect( StringBuilder::new, StringBuilder::append, StringBuilder::append) .toString(); find findAny从流中任意返回一个元素，串行流比较难看到效果 findFirst返回流中第一个元素 // 若流为空，则返回空的Optional Optional&lt;Student> any = stus.stream().findAny(); Optional&lt;Student> first = stus.stream().findFirst(); max、min max：返回流中的最大值 min：返回流中最小值 boxed型的流需要给出自己的比较器，而原始流不需要 toArray()将流中的元素放入到一个数组中。 contact连接两个类型一样的流对象 来一杯理论理论整理来自Javadoc。 基础Stream流和具体的集合区别。 不存储数据：流操作基于数据源对象，但本身不存储数据元素，或者说用完即消(使用者是无感知的)，通过管道将数据源元素传递给操作 函数式编程流操作也不会修改数据源，filter、map都不会对源数据做修改 延迟操作流的很多操作如filter,map等中间操作是延迟执行的，只记录了要怎么操作但还没执行，只有到终点操作才会将操作顺序执行。就像点菜一样，下单过程，不是马上做的，而且确定了订单才根据订单做。 解绑对于无限数量的流，有些操作是可以在有限的时间完成的，比如limit(n) 或 findFirst()，这些操作可以实现”短路”(Short-circuiting)，访问到有限的元素后就可以返回。 纯消费流的元素只能访问一次，类似迭代器Iterator，操作没有回头路，如果你想从头重新访问流的元素，那你得重新生成一个新的流。就是说流操作的每一步都是上一步的结果，而初始数据则是源数据。 流的操作是以管道的方式串起来的。流管道包含一个数据源，接着包含零到N个中间操作，最后以一个终点操作结束。 Stream接口还提供了原语int，long，double级的专门化的流。如IntStream, LongStream 和 DoubleStream。姑且称他们为primitive原始流，是对基本类型执行操作的，不过我们使用流通常是对对象操作。 创建流创建的方法很多，主要有 集合自带的stream()方法 集合的静态Arrays.stream(Object[])方法 流的静态方法，如Stream.of(Object[]) 从文件中获得流，BufferedReader.lines() 文件类Files 操作路径的方法，如list、find、walk等。 随机数流Random.ints() 底层的StreamSupport，它提供了将拆分器Spliterator转换成流的方法。 中间操作 intermediate operations中间操作会返回流对象本身，形成串联的管道，流式风格（fluent style），并且中间操作是延迟的，不会修改源数据，只有在终点操作时才真正执行。 常见的中间操作 filter、distinct、map、peek、sorted、limit、boxed、skip、flatmap、skip、reduce 终点操作 terminal operations终点操作是真正执行的，会将流的最终结果返回。 常见的终点操作 Match、count、collect、find、forEach、forEachOrdered、max、min、reduce、average、toArray 1. 流的串行与并行所有的流操作都可以串行执行或者并行执行。除非显示地创建并行流，否则Java库中创建的都是串行流。 Collection.stream()创建串行流，使用parallel()也可以转为并行流 Collection.parallelStream()创建并行流，使用sequential()方法可以转为串行流。 2. 无干扰 Non-interference流可以从非线程安全的集合中创建，当流的管道执行的时候，非concurrent数据源不应该被改变。 也就是说，在终点操作(管道执行)时，不能对数据源再做修改，避免并发问题产生无法预料的结果 // 这会抛出异常java.util.ConcurrentModificationException List&lt;Integer> l = new ArrayList(Arrays.asList(1, 2)); Stream&lt;Integer> sl = l.stream(); sl.forEach(s -> l.add(3)); // 正常 List&lt;String> l = new ArrayList(Arrays.asList(\"one\", \"two\")); Stream&lt;String> sl = l.stream(); l.add(\"three\"); // 在中间操作修改 sl.forEach(System.out::println); // 使用concurrent的方式,也正常,但可能有无法预料的结果 List&lt;String> l = new CopyOnWriteArrayList&lt;>(Arrays.asList(\"one\", \"two\")); Stream&lt;String> sl = l.stream(); sl.forEach(s -> l.add(\"three\")); CopyOnWriteArrayList的参考 特别的，如果将add换成set，并不会抛异常，因为对象没有被修改，只是内容发生变化。 3. 结合性一个操作或者函数op满足结合性意味着它满足下面的条件 (a op b) op c == a op (b op c) 对于并发流来说，如果操作满足结合性，我们就可以并行计算 a op b op c op d == (a op b) op (c op d) 比如min、max以及字符串连接都是满足结合性的。 4. 排序某些流的返回的元素是有确定顺序的，我们称之为 _encounter order_。 一个流是否是encounter order主要依赖数据源和它的中间操作，比如数据源List和Array上创建的流是有序的(ordered)，但是在HashSet创建的流不是有序的. sorted方法可以将流转换成encounter order的，unordered可以将流转换成encounter order的。 注意，这个方法并不是对元素进行排序或者打散，而是返回一个是否_encounter order_的流 map会用不同的类型替换流中的元素，此时，元素的有序性已经没有意义了。 filter 执行丢弃了一些值，流的类型没有改变 对于串行流，流有序与否不会影响其性能，只是会影响确定性(determinism)，无序流在多次执行的时候结果可能是不一样的。","categories":[{"name":"java","slug":"java","permalink":"http://ghower.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ghower.github.io/tags/java/"},{"name":"新特性","slug":"新特性","permalink":"http://ghower.github.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://ghower.github.io/categories/java/"}]},{"title":"python在列表，元组，字典变量前加_号","slug":"python 在列表，元组，字典变量前加_号。。","date":"2022-03-22T15:28:01.000Z","updated":"2022-03-29T10:15:29.267Z","comments":true,"path":"/post/python 在列表，元组，字典变量前加_号。。.html","link":"","permalink":"http://ghower.github.io/post/python%20%E5%9C%A8%E5%88%97%E8%A1%A8%EF%BC%8C%E5%85%83%E7%BB%84%EF%BC%8C%E5%AD%97%E5%85%B8%E5%8F%98%E9%87%8F%E5%89%8D%E5%8A%A0_%E5%8F%B7%E3%80%82%E3%80%82.html","excerpt":"","text":"标题在python基础学习中可能遗漏这一点，现在补上；在一个列表、元组或字典变量前加*，结果如下 可以发现，在列表前加*号，会将列表拆分成一个一个的独立元素，不光是列表、元组、字典，由numpy生成的向量也可以拆分； 那这些又有什么用呢？了解过函数中*args和**kwargs的人应该知道，这两个形参都接收若干个参数，通常我们将其称为参数组； *args：接收若干个位置参数，转换成元组tuple形式 **kwargs：接收若干个关键字参数，转换成字典dict形式 ps:需要注意的是位置参数*args，一定要在关键字参数**kwargs前看下面的例子； 不难发现，如果不加*，add函数将整个列表当做一个元素使用,也就是add(([1,2,4,5],))。 而带有*号的参数，此时相当于add((1, 2, 4, 5)); *号也可以作用于二维的列表； 显然也是将列表进行拆分，结果是两个一维列表； 结果也与上面所说相同； 这么一看，这个带*变量的作用，就仿佛是把列表解开一层似的，而python中有一个zip函数，功能与之相反。zip是将一个或多个可迭代对象进行包装压缩，返回将结果是列表； 通俗的说：zip()压缩可迭代对象，*号解压可迭代对象； 最后需要注意的是： 可迭代对象才可以使用*号拆分； 带*号变量严格来说并不是一个变量，而更应该称为参数，它是不能赋值给其他变量的，但可以作为参数传递；","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://ghower.github.io/tags/python/"}],"keywords":[]},{"title":"【设计模式】23种设计模式(java)学前必备课！","slug":"【设计模式】23种设计模式(java)学前必备课！","date":"2022-03-22T15:28:01.000Z","updated":"2022-03-29T10:18:47.590Z","comments":true,"path":"/post/【设计模式】23种设计模式(java)学前必备课！.html","link":"","permalink":"http://ghower.github.io/post/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9123%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(java)%E5%AD%A6%E5%89%8D%E5%BF%85%E5%A4%87%E8%AF%BE%EF%BC%81.html","excerpt":"","text":"六大原则这篇只有部分代码实例。 1、单一职责原则(Sington Principle)不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。不要让一个类承担过多的职责，避免职责耦合在一起 2、里氏替换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类（父类）可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类（子类）可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 所有引用基类（父类）的地方必须能透明地使用其子类的对象。 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体实现。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 依赖倒置就是为了解决耦合，让程序依赖抽象。一个简单的例子 // 反例 public class Cat&#123; public void run()&#123;..&#125;; &#125; public class Dog&#123; public void run()&#123;..&#125;; &#125; public class Sys()&#123; private String name; private Cat cat=new Cat(); private Dog dog = new Dog(); public Sys(String name)&#123; this.name = name; &#125; public void autoRun()&#123; if(\"cat\".equals(name))&#123; cat.run(); &#125;else&#123;dog.run();&#125; &#125; &#125; // 应用依赖倒置原则 public interface Animal()&#123; public void run(); &#125; public class Cat implements Animal&#123; @Override public void run()&#123;..&#125;; &#125; public class Dog implements Animal&#123; @Override public void run()&#123;..&#125;; &#125; public class Sys()&#123; private Animal animal; public Sys(Animal animal)&#123; this.animal = animal; &#125; public void autoRun()&#123; animal.run(); &#125; &#125; 可以看出不再于具体实现的Cat和Dog类，而是抽象的Animal接口，加入新的动物时也不用怕。 这种设计也充分说明了，类与类不应该直接依赖细节，因为这样会导致耦合，限制了可扩展性，而是让类与类直接依赖抽象。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 public interface Human&#123; public void run(); public void birth();// 生孩子 &#125; public class man&#123;..&#125; public class woman&#123;..&#125; 如上，man类可能不需要实现接口中的birth方法，而只使用一个接口让两个类实现的话，两个类中就存在不需要的方法，导致接口没有隔离。 单一职责和接口隔离原则 单一职责原则注重的是职责，针对的是程序中的实现和细节； 接口隔离原则注重的是对接口依赖的隔离，主要针对抽象； 5、开闭原则（Open Close Principle）就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不应该去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。依赖倒置中的例子同样违反开闭原则。 6、合成复用原则（Composite And Reuse Principle）CARP原则是尽量优先使用合成/聚合的方式，而不是使用继承。 就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。 复用的两种方式： 合成和继承 一法则7、迪米特法则（最少知道原则）（Demeter Principle）一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，和我这个类没关系，你只需要通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类，尽量少地影响其他模块，降低系统的耦合度，使类与类之间保持松散的耦合关系。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现在成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 设计模式分类总体来说设计模式分三大类： 创建型模式单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为模式模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。","categories":[{"name":"java","slug":"java","permalink":"http://ghower.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ghower.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://ghower.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://ghower.github.io/categories/java/"}]},{"title":"位运算的奇淫巧技","slug":"位运算的奇淫巧技","date":"2022-03-22T15:28:01.000Z","updated":"2022-03-29T10:29:34.593Z","comments":true,"path":"/post/位运算的奇淫巧技.html","link":"","permalink":"http://ghower.github.io/post/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80.html","excerpt":"","text":"基础知识：1. 位掩码在计算机学科及数字逻辑中指的是一串二进制数字，通过与目标数字的按位操作，达到屏蔽指定位而实现需求 位运算yyds位运算永远滴神。。。。 1. 交换两数通过异或运算，交换两个数 a = a^b b = a^b a = a^b 2. 去除两次出现的数从一堆数(出现一次或两次)中除去出现了两次的数 a = a^b a = a^b // a又回到原来的值 这个操作还是比较有意思的。在Leetcode中第一次见到，大呼内行。。a=a^b执行了两次，导致这个b 在没有更改的情况下对自身异或，其结果自然就是0了。差不多是这样的a=(a^b)^b，看成a=a^0，就会发现，这个b没有了，而0与任何数异或都等于它自身。 3. 记录三次出现数说实话还没看懂。。。先记下了 seen_once = seen_twice = 0 // 思路: // -仅当seen_twice未变时，改变seen_once // -仅当seen_once未变时，改变seen_twice //1. 第一次出现 seen_once = ~seen_once &amp; (seen_twice ^ x) seen_twice = ~seen_twice &amp; (seen_once ^ x) //2. 第二次出现 seen_once = ~seen_once &amp; (seen_twice ^ x) seen_twice = ~seen_twice &amp; (seen_once ^ x) //3. 第三次出现 seen_once = ~seen_once &amp; (seen_twice ^ x) seen_twice = ~seen_twice &amp; (seen_once ^ x) 4. 取出最低位的1// 这就能得到一个数，最低位的1 x = x &amp; -x // 或者 x &amp;= -x","categories":[{"name":"算法与题解","slug":"算法与题解","permalink":"http://ghower.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://ghower.github.io/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法与题解","slug":"算法与题解","permalink":"http://ghower.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E9%A2%98%E8%A7%A3/"}]}]}